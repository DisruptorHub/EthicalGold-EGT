<!DOCTYPE html>
<html lang="en">
<!-- Cache Bust Comment: 1 -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Explore the journey of ethically sourced gold with an interactive 3D experience.EthicalGold (EGT) provides transparent, blockchain-verified traceability from mine to market.">
    <title>EthicalGold (EGT) Hologram</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0d1117;
            color: #c9d1d9;
        }
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            touch-action: none;
        }
        .overlay-box {
            position: absolute;
            background: rgba(18, 24, 30, 0.8);
            border: 1px solid #30363d;
            padding: 1.25rem;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            width: 90%;
            max-width: 400px;
            max-height: 80vh;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s ease-in-out, visibility 0.3s;
            z-index: 20;
            pointer-events: auto;
            overflow-y: auto;
        }
         .overlay-box.hidden {
            opacity: 0;
            visibility: hidden;
        }
        .overlay-box h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
            color: #ffffff;
        }
        .overlay-box p {
            font-size: 1rem;
            line-height: 1.6;
        }
        .overlay-box button {
             background-color: #4dd8ff;
             color: #0d1117;
             padding: 0.5rem 1rem;
             border-radius: 8px;
             font-weight: 600;
             cursor: pointer;
             display: block;
             margin: 1.5rem auto 0;
        }
        /* Icon Menu Styles */
        #icon-menu {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(18, 24, 30, 0.5);
            backdrop-filter: blur(5px);
            border: 1px solid #30363d;
            border-radius: 999px;
            padding: 10px;
            z-index: 10;
        }
        #icon-menu button {
            background: none;
            border: none;
            padding: 8px;
            cursor: pointer;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        #icon-menu button:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        #icon-menu svg {
            width: 24px;
            height: 24px;
            fill: #c9d1d9;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="icon-menu">
            <button id="whitepaper-icon" title="White Paper">
                <svg viewBox="0 0 24 24"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"/></svg>
            </button>
            <button id="tokenomics-icon" title="Tokenomics">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-12h2v4h-2zm0 6h2v2h-2z"/></svg>
            </button>
             <button id="community-icon" title="Community">
                <svg viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
            </button>
        </div>
        <div id="overlay-box" class="overlay-box hidden">
            <h3 id="overlay-title"></h3>
            <p id="overlay-text"></p>
            <div id="overlay-button-container"></div>
        </div>
    </div>

    <script>
        window.onload = function() {
            const container = document.getElementById('container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            camera.position.z = 5;

            let starField;
            function createStarfield() {
                const starGeometry = new THREE.BufferGeometry();
                const starCount = 5000;
                const posArray = new Float32Array(starCount * 3);
                for(let i = 0; i < starCount * 3; i++) { posArray[i] = (Math.random() - 0.5) * 2000; }
                starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const starMaterial = new THREE.PointsMaterial({ size: 0.7, color: 0xffffff });
                starField = new THREE.Points(starGeometry, starMaterial);
                scene.add(starField);
            }
            createStarfield();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            const holoMaterial = new THREE.MeshStandardMaterial({
                color: 0x4dd8ff,
                transparent: true,
                opacity: 0.15,
                wireframe: true
            });
            const centralSphere = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 4), holoMaterial);
            centralSphere.name = "central-sphere";
            scene.add(centralSphere);

            const pillarMeshes = [];
            const pillarInfos = {
                "Immutable Traceability & Integrity": { type: 'pillar', text: "Our authentication platform, EthicalGold, uses a dual QR code and NFC chip on a secure, tamper-evident physical tag..." },
                "Empowering Artisanal Communities": { type: 'pillar', text: "A core function of EthicalGold is to directly uplift artisanal miners through secure and fair payment rails..." },
                "Decentralized Governance & Community Ownership": { type: 'pillar', text: "The EthicalGold project is built on a foundation of decentralization, with control and decision-making gradually transitioning to the community through a DAO..." },
                "Sustainable & Ethical Global Standard": { type: 'pillar', text: "EthicalGold is committed to responsible practices that benefit both people and the planet..." },
            };
            
            const constellationShapes = [
                [new THREE.Vector3(0, 0.2, 0), new THREE.Vector3(0.5, 0.5, 0.5), new THREE.Vector3(-0.5, 0.5, -0.5), new THREE.Vector3(0, -0.5, 0)],
                [new THREE.Vector3(-0.5, 0.5, 0), new THREE.Vector3(0.5, 0.5, 0), new THREE.Vector3(0.5, -0.5, 0), new THREE.Vector3(-0.5, -0.5, 0)],
                [new THREE.Vector3(0, 0.6, 0), new THREE.Vector3(-0.5, 0, 0), new THREE.Vector3(0.5, 0, 0), new THREE.Vector3(0, -0.6, 0)],
                [new THREE.Vector3(0.0, 0.0, 0), new THREE.Vector3(0.6, 0.3, 0), new THREE.Vector3(0.3, 0.6, 0), new THREE.Vector3(-0.3, 0.6, 0), new THREE.Vector3(-0.6, 0.3, 0), new THREE.Vector3(-0.6, -0.3,0), new THREE.Vector3(-0.3, -0.6,0), new THREE.Vector3(0.3,-0.6,0), new THREE.Vector3(0.6,-0.3,0)]
            ];
            const pillarColors = [0x8a7905, 0x4caf50, 0x0077b6, 0xffa500];
            const pillarNames = Object.keys(pillarInfos);

            function normalizeAndScale(points, scaleFactor = 0.5) {
                const box = new THREE.Box3().setFromPoints(points);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = scaleFactor / maxDim;
                return points.map(p => p.sub(center).multiplyScalar(scale));
            }

            function updateLayout() {
                const isMobile = window.innerWidth <= 768;
                const pillarDist = isMobile ? 1.9 : 2.4;
                const globeSize = isMobile ? 1.0 : 1.2;
                centralSphere.scale.set(globeSize, globeSize, globeSize);

                const pillarPositions = [
                    new THREE.Vector3(0, pillarDist, 0), new THREE.Vector3(pillarDist, 0, 0),
                    new THREE.Vector3(0, -pillarDist, 0), new THREE.Vector3(-pillarDist, 0, 0)
                ];
                pillarMeshes.forEach((mesh, i) => { mesh.position.copy(pillarPositions[i]); });
            }

            for (let i = 0; i < pillarNames.length; i++) {
                const group = new THREE.Group();
                const normalizedPoints = normalizeAndScale(constellationShapes[i], 0.7);
                const lineMaterial = new THREE.LineBasicMaterial({ color: pillarColors[i], transparent: true, opacity: 0.8 });
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(normalizedPoints);
                const line = new THREE.Line(lineGeometry, lineMaterial);
                group.add(line);
                const pointsMaterial = new THREE.PointsMaterial({ color: pillarColors[i], size: 0.1, sizeAttenuation: true });
                const pointsGeometry = new THREE.BufferGeometry().setFromPoints(normalizedPoints);
                const points = new THREE.Points(pointsGeometry, pointsMaterial);
                group.add(points);
                group.name = `pillar-${pillarNames[i]}`;
                scene.add(group);
                pillarMeshes.push(group);
            }
            
            updateLayout();
            
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let currentSelection = null;
            const overlayBox = document.getElementById('overlay-box');
            const overlayTitle = document.getElementById('overlay-title');
            const overlayText = document.getElementById('overlay-text');
            const overlayButtonContainer = document.getElementById('overlay-button-container');

            function showOverlay(title, text, button_text = null, button_link = null, textAlign = 'left') {
                overlayBox.style.textAlign = textAlign;
                overlayTitle.textContent = title;
                overlayText.textContent = text;
                if (button_text && button_link) {
                    overlayButtonContainer.innerHTML = `<button id="overlay-button">${button_text}</button>`;
                    document.getElementById('overlay-button').addEventListener('click', (e) => {
                        e.stopPropagation();
                        window.open(button_link, '_blank');
                    });
                } else {
                    overlayButtonContainer.innerHTML = '';
                }
                overlayBox.classList.remove('hidden');
            }

            function onMouseClick(event) {
                if (!overlayBox.classList.contains('hidden')) {
                     currentSelection = null;
                     overlayBox.classList.add('hidden');
                     pillarMeshes.forEach(meshGroup => meshGroup.scale.set(1, 1, 1));
                     return;
                }

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                
                const pillarIntersects = raycaster.intersectObjects(pillarMeshes, true);
                const sphereIntersect = raycaster.intersectObject(centralSphere);

                if (pillarIntersects.length > 0) {
                    const clickedPillar = pillarIntersects[0].object.parent;
                    currentSelection = clickedPillar;
                    const pillarName = clickedPillar.name.split('-')[1];
                    showOverlay(pillarName, pillarInfos[pillarName].text);
                } else if (sphereIntersect.length > 0) {
                     currentSelection = centralSphere;
                     showOverlay(
                        "Ethical Sourcing Query",
                        "This feature is currently in development. Soon, you will be able to verify gold assets in real-time using molecular tags.",
                        null, null, 'center'
                     );
                }

                pillarMeshes.forEach(meshGroup => meshGroup.scale.set(1, 1, 1));
                if(currentSelection && pillarMeshes.includes(currentSelection)) { 
                    currentSelection.scale.set(1.5, 1.5, 1.5);
                }
            }
            container.addEventListener('click', onMouseClick, false);

            // --- Icon Menu Listeners ---
            const iconData = {
                "White Paper": { text: "Explore the foundational document of the EthicalGold project, detailing our vision, technology, and roadmap.", buttonText: "Read Full White Paper", buttonLink: "https://github.com/DisruptorHub/EthicalGold-EGT/blob/main/whitepaper.md" },
                "Tokenomics": { text: "Learn about the EGT token's utility, distribution, and the economic model designed to support a sustainable and ethical ecosystem.", buttonText: "Learn More", buttonLink: "#" },
                "Community": { text: "Join the conversation and connect with the EthicalGold community on our social platforms.", buttonText: "Join our Discord", buttonLink: "#" }
            };

            document.getElementById('whitepaper-icon').addEventListener('click', (e) => {
                e.stopPropagation();
                showOverlay("White Paper", iconData["White Paper"].text, iconData["White Paper"].buttonText, iconData["White Paper"].buttonLink, 'center');
            });
            document.getElementById('tokenomics-icon').addEventListener('click', (e) => {
                e.stopPropagation();
                showOverlay("Tokenomics", iconData["Tokenomics"].text, iconData["Tokenomics"].buttonText, iconData["Tokenomics"].buttonLink, 'center');
            });
            document.getElementById('community-icon').addEventListener('click', (e) => {
                e.stopPropagation();
                showOverlay("Community", iconData["Community"].text, iconData["Community"].buttonText, iconData["Community"].buttonLink, 'center');
            });

            function animate() {
                requestAnimationFrame(animate);
                centralSphere.rotation.x += 0.005;
                centralSphere.rotation.y += 0.005;
                if (starField) starField.rotation.y -= 0.0002;
                pillarMeshes.forEach((mesh, i) => mesh.rotation.y += 0.002 + (i * 0.0005));
                renderer.render(scene, camera);
            }
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                updateLayout();
            });
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            function onDocumentMouseDown(event) { isDragging = true; previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY; }
            function onDocumentMouseMove(event) {
                if (isDragging) {
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;
                    centralSphere.rotation.y += deltaX * 0.005;
                    centralSphere.rotation.x += deltaY * 0.005;
                    previousMousePosition.x = event.clientX;
                    previousMousePosition.y = event.clientY;
                }
            }
            function onDocumentMouseUp() { isDragging = false; }
            container.addEventListener('mousedown', onDocumentMouseDown, false);
            container.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('mouseup', onDocumentMouseUp, false);
        };
    </script>
</body>
</html>
```




