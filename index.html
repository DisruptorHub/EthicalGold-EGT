<!DOCTYPE html>
<html lang="en">
<!-- Cache Bust Comment: 1 -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="description" content="Explore the journey of ethically sourced gold with an interactive 3D experience.EthicalGold (EGT) provides transparent, blockchain-verified traceability from mine to market.">
    <title>EthicalGold (EGT) Hologram</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden;
            display: flex;
            flex-direction: column; /* Arrange items vertically */
            height: 100vh;
            background-color: #0d1117;
            color: #c9d1d9;
        }
        #container {
            flex-grow: 1; /* Allow the 3D container to fill available space */
            position: relative;
            width: 100vw;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        .info-box {
            /* This is now the bottom UI bar */
            flex-shrink: 0; /* Prevent the bar from shrinking */
            background: #12181e; /* Solid background */
            border-top: 1px solid #30363d;
            padding: 1rem;
            padding-bottom: calc(1rem + env(safe-area-inset-bottom));
            width: 100%;
            text-align: center;
            z-index: 10;
        }
        .pillar-info-box {
            position: absolute;
            background: rgba(18, 24, 30, 0.9);
            border: 1px solid #30363d;
            padding: 1.5rem;
            border-radius: 12px;
            text-align: left;
            backdrop-filter: blur(8px);
            width: 90%;
            max-width: 450px;
            max-height: 80vh;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: opacity 0.3s ease-in-out, visibility 0.3s;
            z-index: 20;
            pointer-events: auto;
            overflow-y: auto;
        }
         .pillar-info-box.hidden {
            opacity: 0;
            visibility: hidden;
        }
        .pillar-info-box h3 {
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 0.75rem;
            color: #ffffff;
        }
        .pillar-info-box p {
            font-size: 1rem;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div id="container"></div> <!-- 3D Scene Container -->
    
    <div id="main-info-box" class="info-box"> <!-- UI Bar Container -->
        <h1 class="text-base font-bold">EthicalGold (EGT)</h1>
        <div id="trace-toggle-container" class="text-center mt-2">
            <button id="trace-toggle-button" class="bg-green-600 hover:bg-green-700 p-2 rounded-lg text-white font-bold">Ethical Sourcing Query</button>
        </div>
    </div>

    <!-- This pop-up will now appear over the 3D scene only -->
    <div id="pillar-info-display" class="pillar-info-box hidden">
        <h3 id="pillar-info-title"></h3>
        <p id="pillar-info-text"></p>
    </div>

    <script>
        window.onload = function() {
            const container = document.getElementById('container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            camera.position.z = 5;

            let starField;
            function createStarfield() {
                const starGeometry = new THREE.BufferGeometry();
                const starCount = 5000;
                const posArray = new Float32Array(starCount * 3);
                for(let i = 0; i < starCount * 3; i++) {
                    posArray[i] = (Math.random() - 0.5) * 2000;
                }
                starGeometry.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
                const starMaterial = new THREE.PointsMaterial({ size: 0.7, color: 0xffffff });
                starField = new THREE.Points(starGeometry, starMaterial);
                scene.add(starField);
            }
            createStarfield();

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            const holoMaterial = new THREE.MeshStandardMaterial({
                color: 0x238636,
                transparent: true,
                opacity: 0.15,
                wireframe: true
            });
            const centralSphere = new THREE.Mesh(new THREE.IcosahedronGeometry(1, 4), holoMaterial);
            scene.add(centralSphere);

            const pillarMeshes = [];
            
            const pillarColors = [0x8a7905, 0x4caf50, 0x0077b6, 0xffa500];
            const pillarPillarNames = ["Immutable Traceability & Integrity", "Empowering Artisanal Communities", "Decentralized Governance & Community Ownership", "Sustainable & Ethical Global Standard"];
            const pillarInfos = {
                "Immutable Traceability & Integrity": "Our authentication platform, EthicalGold, uses a dual QR code and NFC chip on a secure, tamper-evident physical tag. This tag serves as a secure bridge to an immutable blockchain ledger, providing an unchangeable and transparent record of every gram of gold from its origin. This ensures the integrity of the supply chain and provides buyers with indisputable proof of ethical sourcing, making EGT the standard for trustworthy gold.",
                "Empowering Artisanal Communities": "A core function of EthicalGold is to directly uplift artisanal miners. Through secure and fair payment rails, and by providing essential tools and training, EGT empowers these communities economically, fostering social impact that adds intrinsic value to the gold and the token itself. Our tokenomics incentivize usage, not long-term holding, ensuring the platform's utility is the primary focus. The DApp includes features like 'Miner Spotlights,' where the community can see the faces and stories of the miners their investment is helping.",
                "Decentralized Governance & Community Ownership": "The EthicalGold project is built on a foundation of decentralization, with control and decision-making gradually transitioning to the community through a DAO. This ensures long-term sustainability, community alignment, and provides token holders with a direct voice in the project's evolution, securing the future of their investment. We will not make promises about the project's future value based on the team's efforts, as the value will be a byproduct of the network's adoption and usage.",
                "Sustainable & Ethical Global Standard": "EthicalGold is committed to responsible practices that benefit both people and the planet. By championing ethical sourcing, EGT aims to become the global standard for responsible gold, integrating with a broader ecosystem of ethical goods and positioning the token as a leader in sustainable commerce. We will only source gold from partners who adhere to international standards and the African Union's Pan-African ResourceReporting Code (PARC)."
            };
            
            const constellationShapes = [
                [new THREE.Vector3(0, 0.2, 0), new THREE.Vector3(0.5, 0.5, 0.5), new THREE.Vector3(-0.5, 0.5, -0.5), new THREE.Vector3(0, -0.5, 0)],
                [new THREE.Vector3(-0.5, 0.5, 0), new THREE.Vector3(0.5, 0.5, 0), new THREE.Vector3(0.5, -0.5, 0), new THREE.Vector3(-0.5, -0.5, 0)],
                [new THREE.Vector3(0, 0.6, 0), new THREE.Vector3(-0.5, 0, 0), new THREE.Vector3(0.5, 0, 0), new THREE.Vector3(0, -0.6, 0)],
                [new THREE.Vector3(0.0, 0.0, 0), new THREE.Vector3(0.6, 0.3, 0), new THREE.Vector3(0.3, 0.6, 0), new THREE.Vector3(-0.3, 0.6, 0), new THREE.Vector3(-0.6, 0.3, 0), new THREE.Vector3(-0.6, -0.3,0), new THREE.Vector3(-0.3, -0.6,0), new THREE.Vector3(0.3,-0.6,0), new THREE.Vector3(0.6,-0.3,0)]
            ];
            function normalizeAndScale(points) {
                const box = new THREE.Box3().setFromPoints(points);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 0.6 / maxDim;
                return points.map(p => p.sub(center).multiplyScalar(scale));
            }

            function updateLayout() {
                const isMobile = container.clientWidth <= 768;
                const pillarDistance = isMobile ? 1.7 : 2.2;
                const globeSize = isMobile ? 1.0 : 1.2;

                centralSphere.scale.set(globeSize, globeSize, globeSize);

                const pillarPositions = [
                    new THREE.Vector3(0, pillarDistance, 0), new THREE.Vector3(pillarDistance, 0, 0),
                    new THREE.Vector3(0, -pillarDistance, 0), new THREE.Vector3(-pillarDistance, 0, 0)
                ];

                pillarMeshes.forEach((mesh, i) => {
                    mesh.position.copy(pillarPositions[i]);
                });
            }

            for (let i = 0; i < 4; i++) {
                const group = new THREE.Group();
                const normalizedPoints = normalizeAndScale(constellationShapes[i]);
                if(i !== 0){ normalizedPoints.push(normalizedPoints[0].clone()); }
                const lineMaterial = new THREE.LineBasicMaterial({ color: pillarColors[i], transparent: true, opacity: 0.7 });
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(normalizedPoints);
                const constellationLine = new THREE.Line(lineGeometry, lineMaterial);
                group.add(constellationLine);
                const pointsMaterial = new THREE.PointsMaterial({ color: pillarColors[i], size: 0.1, sizeAttenuation: true });
                const pointsGeometry = new THREE.BufferGeometry().setFromPoints(normalizedPoints);
                const constellationPoints = new THREE.Points(pointsGeometry, pointsMaterial);
                group.add(constellationPoints);
                group.name = `pillar-${pillarPillarNames[i]}`;
                scene.add(group);
                pillarMeshes.push(group);
            }
            
            updateLayout();
            
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let currentPillar = null;

            const pillarInfoBox = document.getElementById('pillar-info-display');
            const pillarInfoTitle = document.getElementById('pillar-info-title');
            const pillarInfoText = document.getElementById('pillar-info-text');

            // The pop-up box now appears inside the main 3D container
            container.appendChild(pillarInfoBox);

            function onMouseClick(event) {
                if (!pillarInfoBox.classList.contains('hidden')) {
                     currentPillar = null;
                     pillarInfoBox.classList.add('hidden');
                     pillarMeshes.forEach(meshGroup => meshGroup.scale.set(1, 1, 1));
                     return;
                }

                mouse.x = (event.clientX / container.clientWidth) * 2 - 1;
                mouse.y = - (event.clientY / container.clientHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(pillarMeshes, true);

                if (intersects.length > 0) {
                    const clickedPillar = intersects[0].object.parent;
                    currentPillar = clickedPillar;
                    const pillarName = clickedPillar.name.split('-')[1];
                    
                    pillarInfoTitle.textContent = pillarName;
                    pillarInfoText.textContent = pillarInfos[pillarName];
                    pillarInfoBox.classList.remove('hidden');
                }

                pillarMeshes.forEach(meshGroup => meshGroup.scale.set(1, 1, 1));
                if(currentPillar) {
                    currentPillar.scale.set(1.5, 1.5, 1.5);
                }
            }
            container.addEventListener('click', onMouseClick, false); // Listen for clicks on the container

            const traceToggleButton = document.getElementById('trace-toggle-button');
            traceToggleButton.addEventListener('click', (event) => {
                event.stopPropagation();
                alert("Ethical Sourcing Query coming soon!");
            });

            function animate() {
                requestAnimationFrame(animate);
                centralSphere.rotation.x += 0.005;
                centralSphere.rotation.y += 0.005;
                if (starField) starField.rotation.y -= 0.0002;
                pillarMeshes.forEach((mesh, i) => mesh.rotation.y += 0.002 + (i * 0.0005));
                
                renderer.render(scene, camera);
            }
            animate();
            
            window.addEventListener('resize', () => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
                updateLayout();
            });
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };
            function onDocumentMouseDown(event) { isDragging = true; previousMousePosition.x = event.clientX; previousMousePosition.y = event.clientY; }
            function onDocumentMouseMove(event) {
                if (isDragging) {
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;
                    centralSphere.rotation.y += deltaX * 0.005;
                    centralSphere.rotation.x += deltaY * 0.005;
                    previousMousePosition.x = event.clientX;
                    previousMousePosition.y = event.clientY;
                }
            }
            function onDocumentMouseUp() { isDragging = false; }
            container.addEventListener('mousedown', onDocumentMouseDown, false);
            container.addEventListener('mousemove', onDocumentMouseMove, false);
            window.addEventListener('mouseup', onDocumentMouseUp, false); // Listen on window for mouseup
        };
    </script>
</body>
</html>
```
